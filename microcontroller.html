<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="images/favicon.png" type="images/jpg">
  <meta content="width=device-width, initial-scale=1" name="viewport" />

  <title>microcontroller project</title>

<link
  href="https://fonts.googleapis.com/css?family=Poppins:200i,300,400&display=swap"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Raleway:700&display=swap"
  rel="stylesheet"
/>

<link href="css/prismdark.css" rel="stylesheet">


<link rel="stylesheet"  href="css/microcontroller.css">
<script type="text/javascript" src="js/java.js"></script>
</head>
<body style="background:white;color:black;">
	<button id = "darkmodebutton" onclick="darkmode()">Dark Mode</button>
	<div id="divID">
		<h1>Implementation of LDR and Temprature Sensor on PIC microcontroller</h1>
		<img src="images/microcontroller.jpg" alt="LDR sensor and temprature sensor Implementationon 8051">
		<p>
			In this project we will interfacing temprature sensor and LDR sensor and 16*2 LCD with PIC microcontroller.
		</p>
			<h2>Components Required:</h2>
			<ul>
				<li>PCB</li>
				<li>PICF184520</li>
				<li>16*2 LCD Display</li>
				<li>LM35 sensor</li>
				<li>LDR sensor</li>
				<li>Potentiometer</li>
				<li>Voltage regulator</li>
				<li>LED</li>
				<li>Buzzer</li>
			</ul>
			<h2>Circuit Diagram:</h2>

			<img src="images/microcontrollerckt.png" alt="Circuit Diagram">

			<h2>Measuring Temprature and Intensity of Light with LM35 and LDR using PIC Microcontroller:</h2>

			<h2>PIC18F4520:</h2>

			<p>PIC18F4520 is a low-cost, low-power, high-speed 8-bit, fully-static Microcontroller unit with 40 pins, 36 of which can be used as I / O pins. It has power-on-reset (POR) and the WDT circuitry (Extended Watchdog Timer), which can be programmed for 4 ms to 131 s.</p>

			<img src="images/pic18f4520.jpg" alt="PICF184520 Diagram">

			<table>
				<tr>
				<b>
					<th>Feature</th>
					<th>PICF184520</th>
				</b>
				</tr>
				<tr>
					<td>ROM (in bytes)</td>
					<td>32KB</td>
				</tr>
				<tr>
					<td>RAM (bytes)</td>
					<td>1536</td>
				</tr>
				<tr>
					<td>Timers</td>
					<td>4(1 x 8-bit,3 x 16-bit)</td>
				</tr>
				<tr>
					<td>I/O pins</td>
					<td>40</td>
				</tr>
				<tr>
					<td>No of I/O port</td>
					<td>36</td>
				</tr>
				<tr>
					<td>ADC Module</td>
					<td>10-bit, 13-channel</td>
				</tr>
				<tr>
					<td>Communication Peripherals</td>
					<td>1 x USART,
					    1 x SPI,
					    1 x I2C
					</td>
				</tr>
				<tr>
					<td>External Oscillator</td>
					<td>Up to 40Mhz</td>
				</tr>
				<tr>
					<td>Internal Osclliator</td>
					<td>8MHz, 32Khz</td>
				</tr>
				<tr>
					<td>CPU Speed (MIPS)</td>
					<td>10 MIPS</td>
				</tr>
			</table>
			<h2>16*2 LCD:</h2>
			<p>
				16*2 LCD is a widely used display for embedded applications. Here is the brief explanation about pins and working of 16*2 LCD display. There are two very important registers inside the LCD. They are data register and command register. Command register is used to send commands such as clear display, cursor at home etc., data register is used to send data which is to be displayed on 16*2 LCD. Below table shows the pin description of 16*2 lcd.
			</p>
			<table>
				<tr>
				<b>
					<th>Pin</th>
					<th>Symbol</th>
					<th>I/O</th>
					<th>Description</th>
				</b>
				</tr>
				<tr>
					<td>1</td>
					<td>Vss</td>
					<td>-</td>
					<td>Ground</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Vdd</td>
					<td>-</td>
					<td>+5V power supply</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Vee</td>
					<td>-</td>
					<td>Power supply to control contrast</td>
				</tr>
				<tr>
					<td>4</td>
					<td>RS</td>
					<td>I</td>
					<td>RS=0 for command register,RS=1 for data register</td>
				</tr>
				<tr>
					<td>5</td>
					<td>RW</td>
					<td>I</td>
					<td>R/W=0 for write, R/W=1 for read</td>
				</tr>
				<tr>
					<td>6</td>
					<td>E</td>
					<td>I/O</td>
					<td>Enable</td>
				</tr>
				<tr>
					<td>7</td>
					<td>D0</td>
					<td>I/O</td>
					<td>8-bit data bus(LSB)</td>
				</tr>
				<tr>
					<td>8</td>
					<td>D1</td>
					<td>I/O</td>
					<td>8-bit data bus</td>
				</tr>
				<tr>
					<td>9</td>
					<td>D2</td>
					<td>I/O</td>
					<td>8-bit data bus</td>
				</tr>
				<tr>
					<td>10</td>
					<td>D3</td>
					<td>I/O</td>
					<td>8-bit data bus</td>
				</tr>
				<tr>
					<td>11</td>
					<td>D4</td>
					<td>I/O</td>
					<td>8-bit data bus</td>
				</tr>
				<tr>
					<td>12</td>
					<td>D5</td>
					<td>I/O</td>
					<td>8-bit data bus</td>
				</tr>
				<tr>
					<td>13</td>
					<td>D6</td>
					<td>I/O</td>
					<td>8-bit data bus</td>
				</tr>
				<tr>
					<td>14</td>
					<td>D7</td>
					<td>I/O</td>
					<td>8-bit data bus(MSB)</td>
				</tr>
				<tr>
					<td>15</td>
					<td>A</td>
					<td>-</td>
					<td>+5v for backlight</td>
				</tr>
				<tr>
					<td>16</td>
					<td>K</td>
					<td>-</td>
					<td>Ground</td>
				</tr>
			</table>
			<h3>The below table shows frequently used LCD command codes.</h3>
            <table>
				<tr>
				<b>
					<th>Code(hex)</th>
					<th>Description</th>
				</b>
				</tr>
				<tr>
					<td>01</td>
					<td>Clear display screen</td>
				</tr>
				<tr>
					<td>06</td>
					<td>Increment cursor (right shift)</td>
				</tr>
				<tr>
					<td>0A</td>
					<td>Display off , cursor on</td>
				</tr>
				<tr>
					<td>0C</td>
					<td>Display on , cursor off</td>
				</tr>
				<tr>
					<td>0F</td>
					<td>Display on , cursor blinking</td>
				</tr>
				<tr>
					<td>80</td>
					<td>Force the cursor to beginning of 1st line</td>
				</tr>
				<tr>
					<td>C0</td>
					<td>Force the cursor to beginning of 2nd line</td>
				</tr>
				<tr>
					<td>38</td>
					<td>2 lines and 5*7 matrix</td>
				</tr>
			</table>
       <h2>LM35 Temperature Sensor:</h2>
       <p>
       	The LM35 is a temperature sensor whose output voltage is linearly proportional to Celsius temperature. The LM35 comes already calibrated hence requires no external calibration. It outputs 10mV for each degree of Celsius temperature.
       	<br>

        LM35 sensor produces voltage corresponding to temperature. This voltage is converted to digital (0 to 256) by ADC0804 and it is fed to 8051 microcontroller. 8051 microcontroller converts this digital value into temperature in degree Celsius. Then this temperature is converted into ascii form which is suitable for displaying. This ascii values are fed to 16*2 lcd which displays the temperature on its screen. This process is repeated after specified interval.
       </p>
       <img src="images/LM35-Pinout.png" alt="LM35 Diagram">

       <h2>LDR (light dependent resistor):</h2>
       <p>
       	Two cadmium sulphide(cds) photoconductive cells with spectral responses
		similar to that of the human eye. The cell resistance falls with increasing light
		intensity. Applications include smoke detection, automatic lighting control,
		batch counting and burglar alarm systems.<br>

		Photoconductive cells are used in many different types of circuits and
		applications.
       </p>
       <img src="images/LDR.jpg" alt="LDR Diagram">

       <h2>LM7805 (voltage regulator):</h2>
       <p>
       	A voltage regulator is a system designed to automatically maintain a constant voltage level. A voltage regulator may use a simple feed-forward design or may include negative feedback. It may use an electromechanical mechanism, or electronic components.
       </p>
       <img src="images/lm7805.png" alt="LM7805 Diagram">

       <h2>Code:</h2>
       <pre>
       	<code class="language-c++">
#include &lt;p18f4520.h&gt;  //Include controller specific .h file

#pragma config OSC = HS //Oscillator Selection
#pragma config WDT = OFF //Disable Watchdog timer
#pragma config LVP = OFF //Disable Low Voltage Programming
#pragma config PBADEN = OFF //Disable PORTB Analog inputs


//Declarations for LCD Connection
#define LCD_DATA    PORTD               //LCD data port
#define en          PORTEbits.RE2      // enable signal
#define rw          PORTEbits.RE1      // read/write signal
#define rs          PORTEbits.RE0     // register select signal
#define LDR         PORTAbits.RA0 
#define Temp        PORTAbits.RA1 
#define led         PORTCbits.RC0   
#define buzzer      PORTCbits.RC1 
#define led1        PORTCbits.RC2
 // register select signal

//Function Prototypes
unsigned int Get_ADC_Result(void);  //Function to Get ADC result after conversion
void Start_Conversion(void);   //Function to Start of Conversion
void msdelay (unsigned int time);  //Function to generate delay
void init_LCD(void);     //Function to initialise the LCD  
void LCD_command(unsigned char cmd); //Function to pass command to the LCD
void LCD_data(unsigned char data);  //Function to write character to the LCD
void LCD_write_string(static char *str);//Function to write string to the LCD

//Start of main program
void main()
{
char msg2[] = "Temp :";
char msg3[] = "NIGHT:";
char msg4[] = "DAY:";
unsigned char i,i1,i2,i3, Thousands,Hundreds,Tens,Ones;
unsigned int adc_val, k=0,adc_val11;
unsigned long Voltage, adc_val3;
float Voltage1, adc_val1,adc_val2;
int result,m, j;
float mV, Temp, Press;
ADCON1 = 0x0F;        //Configuring the PORTE pins as digital I/O
TRISD = 0x00;         //Configuring PORTD as output
TRISE = 0x00;         //Configuring PORTE as output
TRISC = 0x00;         //Configuring PORTC as output
TRISAbits.TRISA0 = 1;   // RA0 is input
TRISAbits.TRISA1 = 1;   // RA1 is input
TRISAbits.TRISA2 = 1;   // RA2 is input
ADC_Init();    // Init ADC peripheral
init_LCD();    // Init LCD Module
LCD_command (0x8F);   // Goto First line, 16th place of LCD
msdelay(15);
 LCD_command (0x07);   // Display shift left
// LCD_write_string(msg1); // Display Message
while(1)
{

  
 if(k==0)
 {
 ADC_Init();    // Init ADC peripheral
LCD_command(0x01);      // clear LCD
   msdelay(15);
 LCD_command(0x06);      // Shift curser right
   msdelay(15);
 LCD_command (0x80);   // Goto first line, 0th place of LCD
 LCD_write_string(msg2); // Display Message
  Start_Conversion();   //Trigger conversion
  adc_val= Get_ADC_Result();//Get the ADC output by polling GO bit
   
 Voltage = (long) adc_val*500.0; //Convert Binary result into temperature
  adc_val = Voltage /1024.0;  
    LCD_command (0x85);   //Goto 5th place on first line of LCD
    i1 = adc_val/100 ;///Get the Hundreds place
  Hundreds = i1 + 0x30;  // Convert it to ASCII
  LCD_data (Hundreds);  //Display Hundreds place
 

i = ((adc_val)%100)/10; //Get the Tens place
  Tens = i + 0x30;   // Convert it to ASCII
  LCD_data (Tens);  //Display Tens place

   i = adc_val%10 ;   //Get the Ones place
  Ones = i + 30;    // Convert it to ASCII
 LCD_data (i + 0x30);   //Display Ones place

    LCD_data ('.'); // Display decimal point

    LCD_data ('0'); // Display 0 digit
   LCD_data (' '); //
LCD_data ('D'); //
LCD_data ('e'); //
LCD_data ('g'); //
LCD_data (' '); //
   LCD_data ('C'); //

if(adc_val &gt; 50)
{
buzzer = 1;
for(j=0;j&lt;6;j++)
led1=1;
msdelay(15);
led1=0;
msdelay(15);

}
else if(adc_val &lt; 50)
{
buzzer = 0;
led = 0;
}
 k=1;
   msdelay(100);  //Delay between conversions. It is a library function,refer delays.h file in MCC18 installation directory
 }

 else if (k==1)
 {
 ADC_Init1();    // Init ADC peripheral
LCD_command (0xC0);   // Goto second line, 0th place of LCD
  // Display Message
  Start_Conversion();   //Trigger conversion

    result = Get_ADC_Result();  // Get the humidity
if (result &lt;100)
{
led=1;
LCD_write_string(msg3);
}
else
{
led=0;
LCD_write_string(msg4);
}

LCD_command (0xC9);   //Goto 9th place on second line of LCD
i = result/1000 ;  //Get the thousands place
 Thousands = i + 0x30;  // Convert it to ASCII
 LCD_data (Thousands); // Display thousands place
 
i = (result%1000)/100; //Get the Hundreds place
Hundreds = i + 0x30;  // Convert it to ASCII
LCD_data (Hundreds);  //Display Hundreds place
 
 i = (result%100)/10; //Get the Tens place
  Tens = i + 0x30;   // Convert it to ASCII
  LCD_data (Tens);   //Display Tens place
  

 i = result%10 ;   //Get the Ones place
  Ones = i + 30;    // Convert it to ASCII
 LCD_data (i + 0x30);  //Display Ones place

 LCD_data ('d'); // Display d
LCD_data ('e'); // Display e
LCD_data ('c'); // Display c

  k=0;
   msdelay(100);
  }

}
}

void Start_Conversion()
{
 ADCON0bits.GO=1;
}

//If you do not wish to use adc conversion interrupt you can use this
//to do conversion manually. It assumes conversion format is right adjusted
unsigned int Get_ADC_Result()
{
unsigned int ADC_Result=0;
while(ADCON0bits.DONE);
 ADC_Result=ADRESL;
 ADC_Result|=((unsigned int)ADRESH) &lt;&lt; 8;
return ADC_Result;
}

void msdelay (unsigned int time) //Function to generate delay
{
unsigned int i, j;
 for (i = 0; i &lt; time; i++)
for (j = 0; j &lt; 710; j++);//Calibrated for a 1 ms delay in MPLAB
}


void init_LCD(void)  // Function to initialise the LCD
{
    LCD_command(0x38);      // initialization of 16X2 LCD in 8bit mode
   msdelay(15);
    LCD_command(0x01);      // clear LCD
   msdelay(15);
    LCD_command(0x0C);      // cursor off
   msdelay(15);
    LCD_command(0x06);      // curser right shift
   msdelay(15);
}

void LCD_command(unsigned char cmd) //Function to pass command to the LCD
{
    LCD_DATA = cmd;  //Send data on LCD data bus
   rs = 0;    //RS = 0 since command to LCD
   rw = 0;    //RW = 0 since writing to LCD
   en = 1;    //Generate High to low pulse on EN
   msdelay(15);
    en = 0;
}

void LCD_data(unsigned char data)//Function to write data to the LCD
{
    LCD_DATA = data; //Send data on LCD data bus
   rs = 1;    //RS = 1 since data to LCD
   rw = 0;    //RW = 0 since writing to LCD
   en = 1;    //Generate High to low pulse on EN
  msdelay(15);
    en = 0;
}
//Function to write string to LCD
void LCD_write_string(static char *str)   
{
   int i = 0;
   while (str[i] != 0)
    {
        LCD_data(str[i]);      // sending data on LCD byte by byte
       msdelay(15);
        i++;
    }
}
       	</code>
       </pre>
	<script src="js/prismdark.js"></script>

	</div>
</body>
</html>